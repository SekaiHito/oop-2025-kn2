## Міністерство освіти і науки України

## Північний кампус Львівського національного університету ветеринарної медицини та біотехнологій імені С.З. Ґжицького.

# Звіт
Про виконання лабораторної роботи №4 з дисципліни "Об'єктно-орієнтоване програмування"

## Тема
Принципи проєктування програмного забезпечення

Виконав: студент групи КН-31 Сологуб Станіслав

Прийняв: доц. Н. Заплатинський

## Львів 2025

## Мета

Мета роботи - познайомитися з найбільш поширеними сучасними принципами проєктування програмного забезпечення

## Шаблони

- DRY (Don’t Repeat Yourself) – уникати дублювання коду.
- KISS (Keep It Simple, Stupid) – простота важливіша за складність.
- YAGNI (You Aren’t Gonna Need It) – не реалізовувати функціонал наперед.
- SOLID – набір із п’яти ключових принципів об’єктно-орієнтованого проєктування.

S — Single Responsibility Principle (Принцип єдиної відповідальності) Клас повинен мати лише одну причину для змін. Це означає, що клас має виконувати лише одну задачу. Наприклад, клас User не повинен займатися збереженням даних у базу (це робота репозиторію) чи відправкою пошти (це робота поштового сервісу).

O — Open/Closed Principle (Принцип відкритості/закритості) Програмні сутності (класи, модулі, функції) повинні бути відкриті для розширення, але закриті для модифікації. Якщо ми хочемо додати нову поведінку, ми створюємо новий код (наприклад, новий клас-нащадок), а не переписуємо старий, робочий код.

L — Liskov Substitution Principle (Принцип підстановки Лісков) Об'єкти базового класу повинні мати можливість бути заміненими об'єктами похідних класів без порушення коректності роботи програми. Простими словами: якщо у нас є функція, яка працює з класом Bird, вона має так само коректно працювати з класом Duck, який успадковується від Bird.

I — Interface Segregation Principle (Принцип розділення інтерфейсу) Клієнти не повинні залежати від інтерфейсів, які вони не використовують. Краще створити багато вузькоспеціалізованих інтерфейсів, ніж один "божественний" інтерфейс загального призначення. Наприклад, замість інтерфейсу IWorker з методами work() та eat(), для робота (який не їсть) краще розділити це на IWorkable та IFeedable.

D — Dependency Inversion Principle (Принцип інверсії залежностей) Модулі верхнього рівня не повинні залежати від модулів нижнього рівня. Обидва повинні залежати від абстракцій. Абстракції не повинні залежати від деталей, деталі повинні залежати від абстракцій. На практиці це означає, що класи повинні залежати від інтерфейсів, а не від конкретних реалізацій (наприклад, залежати від інтерфейсу IDatabase, а не від класу MySQLConnection).



## Хід роботи

- Ознайомився з сучасними принципами проєктування ПЗ (DRY, KISS, YAGNI, SOLID).
- Вивчив принцип Single Responsibility Principle.
- Реалізував приклад на Python: спочатку клас Report мав дві відповідальності, після чого розділив їх між класами Report та ReportSaver.
- Перевірив роботу програми та побудував UML-діаграму для наочного відображення структури.

## Висновок

У роботі розглянуто принципи проєктування ПЗ та детально проаналізовано Single Responsibility Principle.
Приклад показав, що розділення відповідальностей між класами робить систему більш зрозумілою, гнучкою та легкою для підтримки.



## Корисні ресурси

- [Документація Python: Типи даних](https://www.learnpython.org/en/Variables_and_Types)
- [Python для початківців (uk)](https://uk.wikipedia.org/wiki/Python)