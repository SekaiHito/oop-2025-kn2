# МІНІСТЕРСТВО ОСВІТИ ТА НАУКИ

## Львівський національний університет ветеринарії і біотехнологій імені С.З.Ґжицького

# Звіт

**про виконання лаборатоної роботи №15**

**з дисципліни "Об'єктно-орієнтоване програмування"**

**на тему**

**Рефакторинг програмного забезпечення**

Виконав: студент групи КН-31 Сасник Володимир

Перевірив: ст. викладач Назар Заплатинський

### Львів 2025

**Мета роботи - познайомитися з основними принципами та найбільш поширеними техніками рефакторингу програмного забезпечення.**

## Хід роботи

### Загальний опис принципів рефакторингу

    Рефакторинг — це процес покращення структури існуючого коду без зміни його зовнішньої поведінки.
    Мета рефакторингу:
        - зробити код більш зрозумілим, чистим і логічно структурованим;
        - полегшити підтримку і розширення;
        - зменшити ризик помилок при подальшому розвитку програми.

##### Принципи рефакторингу:

    - Мінімальні зміни за один раз — робимо маленькі кроки, що легко тестувати.
    - Тестування після кожної зміни — переконуємося, що поведінка програми не змінилася.
    - Виділення повторюваного коду в окремі функції або класи.
    - Підвищення читаємості коду — зрозумілі назви змінних, методів та класів.
    - Зменшення залежностей — спрощує масштабування і зміну функціоналу.

#### Replace Conditional with Polymorphism - Заміна умовної логіки поліморфізмом

#### Опис принципу

Принцип “Заміна умовної логіки поліморфізмом” належить до технік рефакторингу та спрямований на усунення великих умовних операторів (if/else або switch) у коді, які визначають поведінку об’єкта залежно від його типу або стану.

Ідея полягає в тому, щоб замість розгалужень використовувати поліморфізм — створювати окремі класи або об’єкти, які реалізують специфічну поведінку. Кожен клас-нащадок або стратегія відповідає за свій варіант поведінки, а основний код “сервісу” або менеджера виконує тільки загальні дії, делегуючи специфіку дочірнім класам або стратегіям.

#### Мета

Підвищення читабельності коду: видаляється велика кількість умовних операторів.

Полегшення підтримки: нові варіанти поведінки додаються без зміни існуючого коду.

Дотримання принципу Open/Closed (відкритий для розширення, закритий для змін).

Модульність та тестованість: окремі класи або функції легше перевіряти та повторно використовувати.

#### Проблеми, які вирішує

Надмірна кількість умовних операторів у функціях або методах.

Часті зміни коду через додавання нових гілок if/else.

Велика когнітивна складність при читанні та розумінні логіки.

Порушення принципу єдиної відповідальності (Single Responsibility Principle), коли один клас або метод виконує багато різних дій.

#### Як застосовувати

Виділити умовну логіку, яка залежить від типу об’єкта або стану.

Створити базовий клас або інтерфейс, який описує загальний метод/поведінку.

Створити окремі класи-нащадки або стратегії, які реалізують специфічну поведінку для кожного випадку.

Делегувати виклик методів дочірнім класам, замість того, щоб використовувати умови.

Додавати нові варіанти поведінки через нові класи або функції, без зміни основного коду.

#### Переваги

Легко додавати нові варіанти поведінки.

Основний код залишається чистим та зрозумілим.

Полегшується тестування окремих поведінок.

Підвищується гнучкість системи та зменшується ризик помилок при змінах.

#### Коли використовувати

Коли у коді є велика кількість умовних операторів, що обробляють різні типи об’єктів.

Коли поведінка системи часто змінюється і потрібно додавати нові варіанти.

Коли потрібно покращити модульність, тестованість та підтримку коду.

#### Надмірні залежності (Feature Envy / Tight Coupling)

#### Опис запаху

Надмірні залежності — це запах коду, коли клас або модуль занадто сильно залежить від інших класів чи модулів для виконання своєї роботи.
Такий клас часто використовує дані або методи інших класів більше, ніж власні, що ускладнює його розуміння, тестування та повторне використання.

Feature Envy — специфічний випадок, коли метод одного класу більше зацікавлений у даних іншого класу, ніж у власних.
Tight Coupling — це сильна взаємозалежність між класами, коли зміни в одному класі призводять до змін у багатьох інших.

#### Проблеми, які виникають через надмірні залежності

Важко тестувати клас із-за великої кількості залежностей.

Висока ймовірність помилок при змінах у суміжних класах.

Знижується гнучкість та повторне використання коду.

Складно підтримувати та розширювати систему.

Порушується принцип Single Responsibility Principle (SRP) та Dependency Inversion Principle (DIP).

#### Як розпізнати

Клас часто використовує методи та дані інших класів, більше ніж власні.

Методи одного класу передаються як аргументи для роботи з іншими класами.

При зміні одного класу доводиться змінювати багато інших класів.

Код важко модульно тестувати через необхідність створювати численні залежності.

#### Як усунути

Використовувати інтерфейси або абстракції для зменшення прямої залежності.

Застосовувати інверсію залежностей (Dependency Inversion) через ін’єкцію залежностей.

Переносити методи до класу, який справді володіє потрібними даними (усуваючи Feature Envy).

Розбивати великі класи на менші, із чітко визначеними обов’язками.

Використовувати композицію замість наслідування, щоб зменшити жорсткі зв’язки.

## Висновок:

В ході виконання лабораторної роботи я ознайомився з основними принципами та найбільш поширеними техніками рефакторингу програмного забезпечення.
Було розглянуто поняття “запахів коду”, їх види та наслідки для підтримки та розширюваності системи.
Особливу увагу приділено техніці “Заміна умовної логіки поліморфізмом” (Replace Conditional with Polymorphism) та її застосуванню у класичному та функціональному підходах.
Робота допомогла зрозуміти, як покращувати читабельність, модульність та тестованість коду, а також як зменшити надмірні залежності між класами та методами.
Отримані знання дозволяють застосовувати рефакторинг для створення більш гнучкого, зрозумілого та підтримуваного програмного забезпечення.
